input {
#      beats {
#            port => "5044"
#      }
      file {
           path => "/home/hidepin/log/pgxlog*"
           start_position => "beginning"
           type => "pgxlog"
      }
}
filter {
       mutate {
              gsub => [
                   "source", ".*/", "",
                   "path", ".*/", ""
              ]
       }
       grok {
            match => {
                  "message" => "rmgr: *%{NOTSPACE:rmgr} *len \(rec/tot\): * %{NUMBER:len_rec}/ *%{NUMBER:len_tot}, tx: *%{NUMBER:tx}, lsn: %{NOTSPACE:lsn}, prev %{NOTSPACE:prev}, desc: (?<desc>[^,]*)(?:, blkref #0: rel %{NUMBER:dattablespace}/%{NUMBER:datid}/%{NUMBER:relid} blk %{NUMBER:blk})?"
            }
       }
       if [desc] =~ /^COMMIT/ {
          grok {
               match => {
                     "desc" => "%{NOTSPACE:query} (?<pgxlog_datetime>[^.]*.\d\d\d).*"
               }
          }
          ruby {
               init => "@@pgxlog_datetime = ''"
               code => "
                    @@pgxlog_datetime = event.get('pgxlog_datetime');
                    "
          }
       } else {
          grok {
               match => {
                     "desc" => "%{NOTSPACE:query}.*"
               }
          }
       }
       ruby {
            code => "
                 event.set('pgxlog_datetime', @@pgxlog_datetime);
                 "
       }
       if [pgxlog_datetime] == '' {
          drop {}
       }
       mutate {
              add_field => { "[@metadata][datetime]" => "%{pgxlog_datetime}" }
       }
       date {
            match => [ "[@metadata][datetime]", "yyyy-MM-dd HH:mm:ss.SSS" ]
            timezone => "Asia/Tokyo"
       }
}
output {
       stdout {
              codec => rubydebug
       }
#       elasticsearch {
#                     hosts => '127.0.0.1'
#                     index => "pgxlog-%{+YYYY.MM.dd}"
#       }
}
